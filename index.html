<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Night Racer - Lamborghini Style</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 50, 0.9);
            color: #00ffff;
            padding: 20px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff inset;
            text-align: center;
            z-index: 100;
            display: none;
            font-family: 'Monospace', monospace;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="instructions">
        Use Left/Right Arrow Keys to move the car.
    </div>
    <div id="game-message" class="message-box" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- SCENE SETUP ---
        let scene, camera, renderer;
        let car, road, roadLines = [];
        let buildings = [];
        let distantSkyline = []; 
        let moon;
        let bridgeGroup; 
        const roadWidth = 10;
        const roadLength = 200;
        const buildingSpawnZ = -150;
        const buildingDespawnZ = 50;
        const distantBuildingSpawnZ = -450; 
        const distantBuildingDespawnZ = 100;


        // --- CAR AND CAMERA PARAMETERS ---
        const carSpeed = 0.15;
        const cameraLagFactor = 0.05;
        const cameraSideViewFactor = 0.2;
        let targetCameraX = 0;
        let targetCameraLookX = 0;
        const carModelWidth = 2.2;

        // --- MOVEMENT AND ANIMATION PARAMETERS ---
        const gameSpeed = 1.2;
        const buildingMoveSpeedFactor = 1.0;
        const bridgeMoveSpeedFactor = 0.08; 
        const distantSkylineMoveSpeedFactor = 0.03; 

        // --- INPUT HANDLING ---
        const keys = {
            ArrowLeft: false,
            ArrowRight: false
        };

        window.addEventListener('keydown', (event) => {
            if (keys.hasOwnProperty(event.key)) keys[event.key] = true;
        });
        window.addEventListener('keyup', (event) => {
            if (keys.hasOwnProperty(event.key)) keys[event.key] = false;
        });

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x00001a, 70, 800); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.5, 7);
            camera.lookAt(0, 1, 0);
            scene.add(camera); // Add camera to scene so it can have children

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000005); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404060, 2.0); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x8080ff, 0.1); 
            directionalLight.position.set(5, 1.6155, 2);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight.target);
            scene.add(directionalLight);

            createMoon();
            createCar(); // Car needs to be created before camera light that targets it
            createCameraLight(); // Add light from camera POV
            createRoad();
            createInitialBuildings();
            createInitialDistantSkyline(); 
            createBridge(); 
            animate();
        }

        function createMoon() {
            const moonRadius = 30;
            const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
            
            const textureLoader = new THREE.TextureLoader();
            const moonTexture = textureLoader.load(
                'https://threejs.org/examples/textures/planets/moon_1024.jpg',
                (texture) => { 
                    texture.colorSpace = THREE.SRGBColorSpace; 
                },
                undefined, 
                (err) => { 
                    console.error('Error loading moon texture:', err);
                    moon.material = new THREE.MeshStandardMaterial({
                        color: 0xeeeeee,
                        emissive: 0xdddddd,
                        emissiveIntensity: 3.5 
                    });
                }
            );

            const moonMaterial = new THREE.MeshStandardMaterial({
                map: moonTexture,         
                color: 0xffffff,          
                emissive: 0xffffff,       
                emissiveIntensity: 3.0    
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(0, 120, -700); 
            scene.add(moon);
        }

        function createCameraLight() {
            // Subtle spotlight attached to the camera, pointing at the car
            const cameraLight = new THREE.SpotLight(0xffffff, 0.3, 30, Math.PI / 6, 0.5, 1);
            cameraLight.position.set(0, 1, 2); // Position relative to camera
            // Target will be updated in animate loop to follow the car, or set to car object if car is added to camera light's parent (scene)
            // For simplicity, we'll make it target a point in front of the camera that aligns with the car
            cameraLight.target.position.set(0, 0, -10); // Point forward from camera
            camera.add(cameraLight); // Add light as a child of the camera
            camera.add(cameraLight.target); // Add target as child of camera
        }


        function createCar() {
            car = new THREE.Group();
            scene.add(car); // Add car to the scene so cameraLight can target it
            car.position.y = 0.25;
            car.rotation.y = Math.PI;

            const carMaterial = new THREE.MeshStandardMaterial({
                color: 0xffeb3b,
                metalness: 0.85,
                roughness: 0.15
            });

            const bodyWidth = carModelWidth;
            const bodyHeight = 0.5;
            const bodyLength = 4.5;

            const mainBodyGeometry = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyLength);
            const mainBody = new THREE.Mesh(mainBodyGeometry, carMaterial);
            mainBody.castShadow = true;
            car.add(mainBody);

            const cabinWidth = 1.3;
            const cabinHeight = 0.6;
            const cabinLength = 1.5;
            const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinLength);
            const cabin = new THREE.Mesh(cabinGeometry, carMaterial);
            cabin.position.set(0, (bodyHeight / 2) + (cabinHeight / 2) - 0.1, - (bodyLength / 2) * 0.25);
            cabin.castShadow = true;
            car.add(cabin);

            const windshieldWidth = cabinWidth * 0.95;
            const windshieldHeight = 0.05;
            const windshieldLength = cabinHeight * 0.8;
            const windshieldMaterial = new THREE.MeshStandardMaterial({
                color: 0x222244, transparent: true, opacity: 0.4, roughness: 0.2
            });
            const windshieldGeom = new THREE.BoxGeometry(windshieldWidth, windshieldHeight, windshieldLength);
            const windshield = new THREE.Mesh(windshieldGeom, windshieldMaterial);
            windshield.position.set(
                cabin.position.x, cabin.position.y + cabinHeight * 0.1, cabin.position.z + cabinLength * 0.35
            );
            windshield.rotation.x = -Math.PI / 5;
            car.add(windshield);

            const noseSectionHeight = bodyHeight * 0.6;
            const noseSectionWidth = bodyWidth * 0.9;
            const noseSectionLength = bodyLength * 0.35;
            const noseGeometry = new THREE.BoxGeometry(noseSectionWidth, noseSectionHeight, noseSectionLength);
            const nose = new THREE.Mesh(noseGeometry, carMaterial);
            nose.position.set(0, -bodyHeight * 0.1, (bodyLength / 2) - (noseSectionLength / 2) + 0.1);
            nose.castShadow = true;
            car.add(nose);

            const underglowColor = 0x00ff00;
            const underglowIntensity = 8;
            const underglowDistance = 8;
            const underglowYLocal = -bodyHeight/2 + 0.05;
            const underglow1 = new THREE.PointLight(underglowColor, underglowIntensity, underglowDistance);
            underglow1.position.set(0, underglowYLocal, bodyLength * 0.3);
            car.add(underglow1);
            const underglow2 = new THREE.PointLight(underglowColor, underglowIntensity, underglowDistance);
            underglow2.position.set(0, underglowYLocal, -bodyLength * 0.3);
            car.add(underglow2);

            const headLightHeight = 0.1;
            const headLightWidth = 0.4;
            const headLightDepth = 0.2;
            const headLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffee, emissive: 0xffffee, emissiveIntensity: 1
            });
            const headLightGeom = new THREE.BoxGeometry(headLightWidth, headLightHeight, headLightDepth);
            const headLightMeshL = new THREE.Mesh(headLightGeom, headLightMaterial);
            headLightMeshL.position.set(
                -noseSectionWidth * 0.35, nose.position.y + noseSectionHeight * 0.1,
                nose.position.z + noseSectionLength / 2 - headLightDepth / 2
            );
            car.add(headLightMeshL);
            const headLightMeshR = new THREE.Mesh(headLightGeom, headLightMaterial);
            headLightMeshR.position.set(
                noseSectionWidth * 0.35, nose.position.y + noseSectionHeight * 0.1,
                nose.position.z + noseSectionLength / 2 - headLightDepth / 2
            );
            car.add(headLightMeshR);

            const spotLightColor = 0xffffdd;
            const spotLightIntensity = 42;
            const spotLightDistance = 80;
            const spotLightAngle = Math.PI / 7;
            const spotLightPenumbra = 0.2;
            const actualHeadLightL = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, 1);
            actualHeadLightL.position.set(headLightMeshL.position.x, headLightMeshL.position.y, headLightMeshL.position.z + 0.1);
            actualHeadLightL.target.position.set(headLightMeshL.position.x, headLightMeshL.position.y - 0.5, headLightMeshL.position.z + 15);
            car.add(actualHeadLightL); car.add(actualHeadLightL.target);
            const actualHeadLightR = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, 1);
            actualHeadLightR.position.set(headLightMeshR.position.x, headLightMeshR.position.y, headLightMeshR.position.z + 0.1);
            actualHeadLightR.target.position.set(headLightMeshR.position.x, headLightMeshR.position.y - 0.5, headLightMeshR.position.z + 15);
            car.add(actualHeadLightR); car.add(actualHeadLightR.target);

            const tailLightHeight = 0.15;
            const tailLightWidth = bodyWidth * 0.35;
            const tailLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 3.5
            });
            const tailLightGeometry = new THREE.BoxGeometry(tailLightWidth, tailLightHeight, 0.05);
            const tailLightLMesh = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
            tailLightLMesh.position.set(-bodyWidth * 0.22, 0, -(bodyLength / 2) + 0.02);
            car.add(tailLightLMesh);
            const tailLightRMesh = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
            tailLightRMesh.position.set(bodyWidth * 0.22, 0, -(bodyLength / 2) + 0.02);
            car.add(tailLightRMesh);
        }

        function createRoad() {
            const textureLoader = new THREE.TextureLoader();
            const roadTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', (texture) => {
                texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 10);
            });
            roadTexture.colorSpace = THREE.SRGBColorSpace;
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: roadTexture, color: 0x222222, roughness: 0.8, metalness: 0.1
            });
            const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2; road.position.y = 0;
            road.receiveShadow = true;
            scene.add(road);

            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const lineSegmentLength = 4; const lineGapLength = 4;
            const numLineSegments = Math.floor(roadLength / (lineSegmentLength + lineGapLength));
            for (let i = 0; i < numLineSegments * 2; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.2, lineSegmentLength);
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2; line.position.y = 0.01;
                scene.add(line); roadLines.push(line);
            }
        }

        function createBuilding() {
            const buildingHeight = Math.random() * 30 + 10;
            const buildingWidth = Math.random() * 8 + 4;
            const buildingDepth = Math.random() * 8 + 4;
            const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
            const grayScale = Math.random() * 0.2 + 0.1;
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(grayScale, grayScale, grayScale + 0.05),
                roughness: 0.7, metalness: 0.2
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.castShadow = true;
            building.receiveShadow = true;

            if (Math.random() < 0.98) { 
                const numLights = Math.floor(Math.random() * 20) + 10; 
                for (let i = 0; i < numLights; i++) {
                    let lightColor;
                    let lightIntensity;
                    let lightWidth;
                    let lightHeight;

                    if (Math.random() < 0.90) { 
                        lightColor = 0xffd700; 
                        lightIntensity = 3.0 + Math.random() * 2.0; 
                        lightWidth = Math.random() * (buildingWidth * 0.10) + 0.15; 
                        lightHeight = Math.random() * (buildingHeight * 0.07) + 0.15; 
                    } else { 
                        const otherNeonColors = [0xff00ff, 0x00ffff, 0xff4500, 0x33cc33, 0x6666ff, 0xff8c00, 0xcc00cc]; 
                        lightColor = otherNeonColors[Math.floor(Math.random() * otherNeonColors.length)];
                        lightIntensity = 2.8 + Math.random() * 1.2; 
                        lightWidth = Math.random() * (buildingWidth * 0.30) + 0.3;
                        lightHeight = Math.random() * (buildingHeight * 0.18) + 0.25;
                    }

                    const lightMaterial = new THREE.MeshStandardMaterial({
                        emissive: lightColor,
                        emissiveIntensity: lightIntensity,
                        color: lightColor 
                    });

                    const lightGeometry = new THREE.PlaneGeometry(lightWidth, lightHeight);
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    
                    const faceMarginX = buildingWidth * 0.05; 
                    const faceMarginZ = buildingDepth * 0.05;
                    const faceMarginY = buildingHeight * 0.05;

                    const randomY = (Math.random() * (buildingHeight - 2 * faceMarginY - lightHeight)) - ((buildingHeight - lightHeight)/ 2 - faceMarginY);
                    const randomXOnFace = (Math.random() * (buildingWidth - 2 * faceMarginX - lightWidth)) - ((buildingWidth - lightWidth)/ 2 - faceMarginX);
                    const randomZOnFace = (Math.random() * (buildingDepth - 2 * faceMarginZ - (light.rotation.y === 0 || light.rotation.y === Math.PI ? lightWidth : lightHeight) )) - ((buildingDepth - (light.rotation.y === 0 || light.rotation.y === Math.PI ? lightWidth : lightHeight))/ 2 - faceMarginZ);

                    const side = Math.floor(Math.random() * 4);
                    const surfaceOffset = 0.051; 

                    if (side === 0) { 
                        light.position.set(buildingWidth / 2 + surfaceOffset, randomY, randomZOnFace);
                        light.rotation.y = Math.PI / 2;
                    } else if (side === 1) { 
                        light.position.set(-buildingWidth / 2 - surfaceOffset, randomY, randomZOnFace);
                        light.rotation.y = -Math.PI / 2;
                    } else if (side === 2) { 
                        light.position.set(randomXOnFace, randomY, buildingDepth / 2 + surfaceOffset);
                    } else { 
                        light.position.set(randomXOnFace, randomY, -buildingDepth / 2 - surfaceOffset);
                        light.rotation.y = Math.PI;
                    }
                    building.add(light);
                }
            }
            building.position.y = buildingHeight / 2;
            return building;
        }

        function createInitialBuildings() {
            const initialBuildingCount = 30;
            for (let i = 0; i < initialBuildingCount; i++) {
                const buildingL = createBuilding();
                buildingL.position.x = -(roadWidth / 2 + buildingL.geometry.parameters.width / 2 + Math.random() * 10);
                buildingL.position.z = buildingSpawnZ + (i / initialBuildingCount) * (buildingDespawnZ - buildingSpawnZ) * 3;
                scene.add(buildingL); buildings.push(buildingL);
                const buildingR = createBuilding();
                buildingR.position.x = (roadWidth / 2 + buildingR.geometry.parameters.width / 2 + Math.random() * 10);
                buildingR.position.z = buildingSpawnZ + (i / initialBuildingCount) * (buildingDespawnZ - buildingSpawnZ) * 3;
                scene.add(buildingR); buildings.push(buildingR);
            }
        }

        function createDistantBuilding() {
            const buildingHeight = Math.random() * 80 + 40; 
            const buildingWidth = Math.random() * 20 + 10; 
            const buildingDepth = Math.random() * 20 + 10;
            const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
            const distantBuildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x101018, 
                roughness: 0.9,
                metalness: 0.1
            });
            const building = new THREE.Mesh(buildingGeometry, distantBuildingMaterial);

            if (Math.random() < 0.1) { 
                const numDimLights = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < numDimLights; i++) {
                    const dimLightMaterial = new THREE.MeshBasicMaterial({ color: 0x333322 }); 
                    const dimLightGeom = new THREE.PlaneGeometry(Math.random() * 2 + 0.5, Math.random() * 2 + 0.5);
                    const dimLight = new THREE.Mesh(dimLightGeom, dimLightMaterial);
                    dimLight.position.set(
                        (Math.random() - 0.5) * buildingWidth * 0.8,
                        (Math.random() - 0.5) * buildingHeight * 0.8,
                        (Math.random() > 0.5 ? buildingDepth / 2 : -buildingDepth/2) + (Math.random() > 0.5 ? 0.05 : -0.05)
                    );
                     if(dimLight.position.z > buildingDepth/2) dimLight.rotation.y = 0; else dimLight.rotation.y = Math.PI;

                    building.add(dimLight);
                }
            }
            building.position.y = buildingHeight / 2; 
            return building;
        }

        function createInitialDistantSkyline() {
            const numDistantBuildings = 20; 
            for (let i = 0; i < numDistantBuildings; i++) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const distantBuilding = createDistantBuilding();
                distantBuilding.position.x = side * (roadWidth + Math.random() * 100 + distantBuilding.geometry.parameters.width/2); 
                distantBuilding.position.z = distantBuildingSpawnZ - Math.random() * 200; 
                scene.add(distantBuilding);
                distantSkyline.push(distantBuilding);
            }
        }

        function updateDistantSkyline() {
            distantSkyline.forEach(building => {
                building.position.z += gameSpeed * distantSkylineMoveSpeedFactor;
                if (building.position.z > distantBuildingDespawnZ) {
                    building.position.z = distantBuildingSpawnZ - Math.random() * 50;
                    const side = Math.random() > 0.5 ? 1 : -1;
                    building.position.x = side * (roadWidth + Math.random() * 100 + building.geometry.parameters.width/2);
                }
            });
        }
        
        function createBridge() {
            bridgeGroup = new THREE.Group(); 
            const bridgeBaseZ = -300; 
            bridgeGroup.position.z = bridgeBaseZ;
            bridgeGroup.rotation.y = Math.PI / 2; // Rotate bridge to be perpendicular to the road
            scene.add(bridgeGroup);

            const bridgeRedMaterial = new THREE.MeshStandardMaterial({ color: 0xcc0000, roughness: 0.6, metalness: 0.3 });
            const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.5, metalness: 0.7 });

            const roadwayWidth = 12;
            const roadwayHeight = 0.5;
            const roadwayLength = 60; 
            const roadwayGeometry = new THREE.BoxGeometry(roadwayWidth, roadwayHeight, roadwayLength);
            const roadway = new THREE.Mesh(roadwayGeometry, bridgeRedMaterial);
            roadway.position.y = 15; 
            bridgeGroup.add(roadway);

            const towerWidth = 2;
            const towerHeight = 70; 
            const towerDepth = 2;
            const towerGeometry = new THREE.BoxGeometry(towerWidth, towerHeight, towerDepth);

            const towerL = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerL.position.set(-(roadwayWidth / 2 + towerWidth / 2), roadway.position.y + towerHeight / 2 - roadwayHeight / 2, -roadwayLength / 2 + 5);
            bridgeGroup.add(towerL);

            const towerR = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerR.position.set(roadwayWidth / 2 + towerWidth / 2, roadway.position.y + towerHeight / 2 - roadwayHeight / 2, -roadwayLength / 2 + 5);
            bridgeGroup.add(towerR);
            
            const towerL2 = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerL2.position.set(-(roadwayWidth / 2 + towerWidth / 2), roadway.position.y + towerHeight / 2 - roadwayHeight / 2, roadwayLength / 2 - 5);
            bridgeGroup.add(towerL2);

            const towerR2 = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerR2.position.set(roadwayWidth / 2 + towerWidth / 2, roadway.position.y + towerHeight / 2 - roadwayHeight / 2, roadwayLength / 2 - 5);
            bridgeGroup.add(towerR2);

            const mainCableRadius = 0.2;
            const mainCableSegments = 5; 
            const cableSpan = roadwayLength - 10; 
            const cableSag = 15; 

            for (let side = -1; side <= 1; side += 2) { 
                const cableStartX = side * (roadwayWidth / 2 + towerWidth / 2 - mainCableRadius * 2);
                const cableTopY = roadway.position.y + towerHeight - roadwayHeight/2 - mainCableRadius;
                let prevPoint = new THREE.Vector3(cableStartX, cableTopY, -cableSpan / 2);

                for (let i = 1; i <= mainCableSegments; i++) {
                    const t = i / mainCableSegments;
                    const currentX = cableStartX;
                    const currentY = cableTopY - cableSag * (1 - Math.pow(2 * t - 1, 2)); 
                    const currentZ = -cableSpan / 2 + t * cableSpan;
                    const nextPoint = new THREE.Vector3(currentX, currentY, currentZ);
                    const segmentLength = prevPoint.distanceTo(nextPoint);
                    const cableSegmentGeom = new THREE.BoxGeometry(mainCableRadius*2, mainCableRadius*2, segmentLength);
                    const cableSegment = new THREE.Mesh(cableSegmentGeom, cableMaterial);
                    cableSegment.position.copy(prevPoint).lerp(nextPoint, 0.5); 
                    cableSegment.lookAt(nextPoint); 
                    bridgeGroup.add(cableSegment);
                    prevPoint = nextPoint;
                }
            }

            const suspenderRadius = 0.05;
            const numSuspenders = 10; 
            for (let side = -1; side <= 1; side += 2) {
                 const mainCableX = side * (roadwayWidth / 2 + towerWidth / 2 - mainCableRadius*2);
                for (let i = 0; i <= numSuspenders; i++) {
                    const t = i / numSuspenders;
                    const suspenderZ = -cableSpan / 2 + t * cableSpan;
                    const mainCableY = (roadway.position.y + towerHeight - roadwayHeight/2 - mainCableRadius) - cableSag * (1 - Math.pow(2 * ( (suspenderZ + cableSpan/2) / cableSpan ) - 1, 2));
                    const suspenderHeight = mainCableY - (roadway.position.y + roadwayHeight / 2); 
                    if (suspenderHeight <= 0) continue; 
                    const suspenderGeom = new THREE.CylinderGeometry(suspenderRadius, suspenderRadius, suspenderHeight, 6);
                    const suspender = new THREE.Mesh(suspenderGeom, cableMaterial);
                    suspender.position.set(mainCableX, roadway.position.y + roadwayHeight / 2 + suspenderHeight / 2, suspenderZ);
                    bridgeGroup.add(suspender);
                }
            }
        }


        function updateRoad() {
            if (road.material.map) {
                road.material.map.offset.y -= gameSpeed * 0.02;
            }
            roadLines.forEach((line, index) => {
                const isLeftLane = index < roadLines.length / 2;
                const lineBaseX = isLeftLane ? -roadWidth / 4 : roadWidth / 4;
                line.position.x = lineBaseX;
                let currentZ = line.userData.initialZ !== undefined ? line.userData.initialZ : (index % (roadLines.length / 2)) * 8 - roadLength / 2;
                currentZ += gameSpeed;
                if (currentZ > roadLength / 2) { currentZ -= roadLength; }
                line.userData.initialZ = currentZ; line.position.z = currentZ;
            });
        }

        function updateBuildingsAndBridge() {
            buildings.forEach(building => {
                building.position.z += gameSpeed * buildingMoveSpeedFactor;
                if (building.position.z > buildingDespawnZ) {
                    building.position.z = buildingSpawnZ - Math.random() * 30;
                    const side = building.position.x < 0 ? -1 : 1;
                    building.position.x = side * (roadWidth / 2 + building.geometry.parameters.width / 2 + Math.random() * 10);
                }
            });
            if (bridgeGroup) { 
                bridgeGroup.position.z += gameSpeed * bridgeMoveSpeedFactor;
                if (bridgeGroup.position.z > distantBuildingDespawnZ + 150) { 
                    bridgeGroup.position.z = distantBuildingSpawnZ - 200; 
                }
            }
        }

        function handleCarMovement() {
            const roadBoundary = roadWidth / 2 - carModelWidth / 2 - 0.1;
            if (keys.ArrowLeft) {
                car.position.x = Math.max(car.position.x - carSpeed, -roadBoundary);
            }
            if (keys.ArrowRight) {
                car.position.x = Math.min(car.position.x + carSpeed, roadBoundary);
            }
            targetCameraX = car.position.x * cameraSideViewFactor;
            targetCameraLookX = car.position.x * 0.8;
            camera.position.x += (targetCameraX - camera.position.x) * cameraLagFactor;
            
            // Update camera light target to follow the car
            if (scene.getObjectByName("cameraLightTarget")) { // Ensure car is defined
                // The target for the camera's light is a child of the camera.
                // We want it to point towards the car's world position.
                // So, we need to transform the car's world position to the camera's local space.
                const targetPosition = new THREE.Vector3();
                car.getWorldPosition(targetPosition); // Get car's world position
                camera.worldToLocal(targetPosition);  // Convert to camera's local space
                scene.getObjectByName("cameraLightTarget").position.copy(targetPosition);
            }


            const lookAtPosition = new THREE.Vector3(
                targetCameraLookX, camera.position.y - 1.0, car.position.z - 10
            );
            camera.lookAt(lookAtPosition);
        }

        function animate() {
            requestAnimationFrame(animate);
            handleCarMovement();
            updateRoad();
            updateBuildingsAndBridge();
            updateDistantSkyline(); 
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        init();
    </script>
</body>
</html>
