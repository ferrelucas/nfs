<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Night Racer - Lamborghini Style</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 30, 50, 0.9);
            color: #00ffff;
            padding: 20px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff inset;
            text-align: center;
            z-index: 100;
            display: none;
            font-family: 'Monospace', monospace;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="instructions">
        Use Left/Right Arrow Keys to move the car.
    </div>
    <div id="game-message" class="message-box" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- SCENE SETUP ---
        let scene, camera, renderer;
        let car, road, roadLines = [];
        let buildings = [];
        let distantSkyline = []; 
        let moon; 
        let bridgeGroup; 
        let lightPosts = []; 
        const roadWidth = 10;
        const roadLength = 200;
        const buildingSpawnZ = -150;
        const buildingDespawnZ = 50;
        const distantBuildingSpawnZ = -450; 
        const distantBuildingDespawnZ = 100;
        const lightPostSpawnZ = -100;
        const lightPostDespawnZ = 30;
        const lightPostSpacing = 40; 


        // --- CAR AND CAMERA PARAMETERS ---
        const carSpeed = 0.15;
        const cameraLagFactor = 0.05;
        const cameraSideViewFactor = 0.2;
        let targetCameraX = 0;
        let targetCameraLookX = 0;
        const carModelWidth = 2.2;

        // --- MOVEMENT AND ANIMATION PARAMETERS ---
        const gameSpeed = 1.2;
        const buildingMoveSpeedFactor = 1.0;
        const bridgeMoveSpeedFactor = 0.08; 
        const distantSkylineMoveSpeedFactor = 0.03; 
        const lightPostMoveSpeedFactor = 1.0;

        // --- INPUT HANDLING ---
        const keys = {
            ArrowLeft: false,
            ArrowRight: false
        };

        window.addEventListener('keydown', (event) => {
            if (keys.hasOwnProperty(event.key)) keys[event.key] = true;
        });
        window.addEventListener('keyup', (event) => {
            if (keys.hasOwnProperty(event.key)) keys[event.key] = false;
        });

        function init() {
            try {
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x00001a, 70, 800); 

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2.5, 7);
                camera.lookAt(0, 1, 0);
                scene.add(camera); 

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor(0x000005); 
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                document.body.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x404060, 1.8); 
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x8080ff, 0.1); // Slightly increased from 0.05
                directionalLight.position.set(5, 1.6155, 2);
                directionalLight.target.position.set(0, 0, 0);
                scene.add(directionalLight.target);
                scene.add(directionalLight);

                createMoon();
                createCar(); 
                createCameraLight(); 
                createRoad();
                createInitialBuildings();
                createInitialDistantSkyline(); 
                createBridge(); 
                createInitialLightPosts(); 
                animate();
            } catch (error) {
                console.error("Error during initialization:", error);
                const instructionsDiv = document.getElementById('instructions');
                if (instructionsDiv) {
                    instructionsDiv.innerHTML = "Error initializing game. Check console (F12) for details.";
                    instructionsDiv.style.color = "red";
                    instructionsDiv.style.backgroundColor = "black";
                }
            }
        }

        function createMoon() {
            const moonRadius = 30;
            const moonGeometry = new THREE.SphereGeometry(moonRadius, 32, 32);
            
            // Initial/Fallback material
            const initialMoonMaterial = new THREE.MeshStandardMaterial({
                color: 0xeeeeee, // A neutral grey if texture fails
                emissive: 0xdddddd,
                emissiveIntensity: 1.0 
            });
            moon = new THREE.Mesh(moonGeometry, initialMoonMaterial);
            moon.position.set(0, 120, -700); 
            scene.add(moon);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'https://threejs.org/examples/textures/planets/moon_1024.jpg',
                (texture) => { // onLoad callback
                    texture.colorSpace = THREE.SRGBColorSpace; 
                    moon.material.map = texture;
                    moon.material.color.set(0xffffff); 
                    moon.material.emissive.set(0xfff0a0); 
                    moon.material.emissiveIntensity = 12.0; 
                    moon.material.needsUpdate = true;
                },
                undefined, // onProgress callback (optional)
                (err) => { // onError callback
                    console.error('Error loading moon texture. Using fallback material.', err);
                    // Ensure fallback is explicitly set if error occurs after initial material assignment
                    moon.material.color.set(0xfff8e1);
                    moon.material.emissive.set(0xfff0a0);
                    moon.material.emissiveIntensity = 12.0;
                    moon.material.map = null; 
                    moon.material.needsUpdate = true;
                }
            );
        }

        function createCameraLight() {
            const cameraLight = new THREE.SpotLight(0xffffff, 0.25, 30, Math.PI / 7, 0.4, 1); 
            cameraLight.name = "cameraLight"; 
            cameraLight.position.set(0, 1, 2.5); 
            
            const cameraLightTarget = new THREE.Object3D();
            cameraLightTarget.name = "cameraLightTarget";
            cameraLight.target = cameraLightTarget;
            camera.add(cameraLightTarget); 
            
            camera.add(cameraLight); 
        }


        function createCar() {
            car = new THREE.Group();
            scene.add(car); 
            car.position.y = 0.25;
            car.rotation.y = Math.PI; 

            const carColor = 0xffeb3b; 
            const carMaterial = new THREE.MeshStandardMaterial({
                color: carColor,      
                metalness: 0.95,        
                roughness: 0.05,        
                emissive: carColor,       
                emissiveIntensity: 0.15,  
                clearcoat: 1.0,         
                clearcoatRoughness: 0.03 
            });

            const bodyWidth = carModelWidth;
            const bodyHeight = 0.5;
            const bodyLength = 4.5;

            const mainBodyGeometry = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyLength);
            const mainBody = new THREE.Mesh(mainBodyGeometry, carMaterial);
            mainBody.castShadow = true;
            car.add(mainBody);

            const cabinWidth = 1.3;
            const cabinHeight = 0.6;
            const cabinLength = 1.5;
            const cabinGeometry = new THREE.BoxGeometry(cabinWidth, cabinHeight, cabinLength);
            const cabin = new THREE.Mesh(cabinGeometry, carMaterial); 
            cabin.position.set(0, (bodyHeight / 2) + (cabinHeight / 2) - 0.1, - (bodyLength / 2) * 0.25);
            cabin.castShadow = true;
            car.add(cabin);

            const windshieldWidth = cabinWidth * 0.95;
            const windshieldHeight = 0.05;
            const windshieldLength = cabinHeight * 0.8;
            const windshieldMaterial = new THREE.MeshStandardMaterial({
                color: 0x222244, transparent: true, opacity: 0.4, roughness: 0.2
            });
            const windshieldGeom = new THREE.BoxGeometry(windshieldWidth, windshieldHeight, windshieldLength);
            const windshield = new THREE.Mesh(windshieldGeom, windshieldMaterial);
            windshield.position.set(
                cabin.position.x, cabin.position.y + cabinHeight * 0.1, cabin.position.z + cabinLength * 0.35
            );
            windshield.rotation.x = -Math.PI / 5;
            car.add(windshield);

            const noseSectionHeight = bodyHeight * 0.6;
            const noseSectionWidth = bodyWidth * 0.9;
            const noseSectionLength = bodyLength * 0.35;
            const noseGeometry = new THREE.BoxGeometry(noseSectionWidth, noseSectionHeight, noseSectionLength);
            const nose = new THREE.Mesh(noseGeometry, carMaterial); 
            nose.position.set(0, -bodyHeight * 0.1, (bodyLength / 2) - (noseSectionLength / 2) + 0.1);
            nose.castShadow = true;
            car.add(nose);

            const underglowStripHeight = 0.05;
            const underglowStripThickness = 0.1;
            const underglowLength = bodyLength * 0.75;
            const underglowMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 2.5
            });

            const underglowLeftGeometry = new THREE.BoxGeometry(underglowStripThickness, underglowStripHeight, underglowLength);
            const underglowLeft = new THREE.Mesh(underglowLeftGeometry, underglowMaterial);
            underglowLeft.position.set(-(bodyWidth / 2 - underglowStripThickness / 2 - 0.05), -bodyHeight / 2 - underglowStripHeight / 2 + 0.02, 0);
            car.add(underglowLeft);

            const underglowRightGeometry = new THREE.BoxGeometry(underglowStripThickness, underglowStripHeight, underglowLength);
            const underglowRight = new THREE.Mesh(underglowRightGeometry, underglowMaterial);
            underglowRight.position.set(bodyWidth / 2 - underglowStripThickness / 2 - 0.05, -bodyHeight / 2 - underglowStripHeight / 2 + 0.02, 0);
            car.add(underglowRight);


            const headLightHeight = 0.1;
            const headLightWidth = 0.4;
            const headLightDepth = 0.2;
            const headLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffee, emissive: 0xffffee, emissiveIntensity: 1
            });
            const headLightGeom = new THREE.BoxGeometry(headLightWidth, headLightHeight, headLightDepth);
            const headLightMeshL = new THREE.Mesh(headLightGeom, headLightMaterial);
            headLightMeshL.position.set(
                -noseSectionWidth * 0.35, nose.position.y + noseSectionHeight * 0.1,
                nose.position.z + noseSectionLength / 2 - headLightDepth / 2
            );
            car.add(headLightMeshL);
            const headLightMeshR = new THREE.Mesh(headLightGeom, headLightMaterial);
            headLightMeshR.position.set(
                noseSectionWidth * 0.35, nose.position.y + noseSectionHeight * 0.1,
                nose.position.z + noseSectionLength / 2 - headLightDepth / 2
            );
            car.add(headLightMeshR);

            const spotLightColor = 0xffffdd;
            const spotLightIntensity = 42;
            const spotLightDistance = 80;
            const spotLightAngle = Math.PI / 7;
            const spotLightPenumbra = 0.2;
            const actualHeadLightL = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, 1);
            actualHeadLightL.position.set(headLightMeshL.position.x, headLightMeshL.position.y, headLightMeshL.position.z + 0.1);
            actualHeadLightL.target.position.set(headLightMeshL.position.x, headLightMeshL.position.y - 0.5, headLightMeshL.position.z + 15);
            car.add(actualHeadLightL); car.add(actualHeadLightL.target);
            const actualHeadLightR = new THREE.SpotLight(spotLightColor, spotLightIntensity, spotLightDistance, spotLightAngle, spotLightPenumbra, 1);
            actualHeadLightR.position.set(headLightMeshR.position.x, headLightMeshR.position.y, headLightMeshR.position.z + 0.1);
            actualHeadLightR.target.position.set(headLightMeshR.position.x, headLightMeshR.position.y - 0.5, headLightMeshR.position.z + 15);
            car.add(actualHeadLightR); car.add(actualHeadLightR.target);

            const tlWidth = bodyWidth * 0.35; 
            const tlHeight = 0.15;          
            const tlCornerRadius = Math.min(tlWidth, tlHeight) * 0.3;
            const tlDepth = 0.08; 

            const tailLightShape = new THREE.Shape();
            const x = -tlWidth / 2;
            const y = -tlHeight / 2;

            tailLightShape.moveTo( x, y + tlCornerRadius );
            tailLightShape.lineTo( x, y + tlHeight - tlCornerRadius );
            tailLightShape.quadraticCurveTo( x, y + tlHeight, x + tlCornerRadius, y + tlHeight );
            tailLightShape.lineTo( x + tlWidth - tlCornerRadius, y + tlHeight );
            tailLightShape.quadraticCurveTo( x + tlWidth, y + tlHeight, x + tlWidth, y + tlHeight - tlCornerRadius );
            tailLightShape.lineTo( x + tlWidth, y + tlCornerRadius );
            tailLightShape.quadraticCurveTo( x + tlWidth, y, x + tlWidth - tlCornerRadius, y );
            tailLightShape.lineTo( x + tlCornerRadius, y );
            tailLightShape.quadraticCurveTo( x, y, x, y + tlCornerRadius );

            const extrudeSettings = { depth: tlDepth, bevelEnabled: false };
            const tailLightRoundedGeometry = new THREE.ExtrudeGeometry( tailLightShape, extrudeSettings );

            const tailLightMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 3.5
            });
            
            const tailLightLMesh = new THREE.Mesh(tailLightRoundedGeometry, tailLightMaterial);
            tailLightLMesh.position.set(-bodyWidth * 0.22, 0, -(bodyLength / 2) + 0.02 + tlDepth/2); 
            car.add(tailLightLMesh);
            
            const tailLightRMesh = new THREE.Mesh(tailLightRoundedGeometry, tailLightMaterial);
            tailLightRMesh.position.set(bodyWidth * 0.22, 0, -(bodyLength / 2) + 0.02 + tlDepth/2); 
            car.add(tailLightRMesh);

            const rearSpotLightColor = 0xff0000;
            const rearSpotLightIntensity = 7.5; 
            const rearSpotLightDistance = 25;
            const rearSpotLightAngle = Math.PI / 8; 
            const rearSpotLightPenumbra = 0.4;
            const rearSpotLightDecay = 1.5;

            const actualTailLightL = new THREE.SpotLight(rearSpotLightColor, rearSpotLightIntensity, rearSpotLightDistance, rearSpotLightAngle, rearSpotLightPenumbra, rearSpotLightDecay);
            actualTailLightL.position.set(tailLightLMesh.position.x, tailLightLMesh.position.y, tailLightLMesh.position.z - tlDepth); 
            actualTailLightL.target.position.set(actualTailLightL.position.x, actualTailLightL.position.y, actualTailLightL.position.z - 10); 
            car.add(actualTailLightL);
            car.add(actualTailLightL.target);

            const actualTailLightR = new THREE.SpotLight(rearSpotLightColor, rearSpotLightIntensity, rearSpotLightDistance, rearSpotLightAngle, rearSpotLightPenumbra, rearSpotLightDecay);
            actualTailLightR.position.set(tailLightRMesh.position.x, tailLightRMesh.position.y, tailLightRMesh.position.z - tlDepth);
            actualTailLightR.target.position.set(actualTailLightR.position.x, actualTailLightR.position.y, actualTailLightR.position.z - 10);
            car.add(actualTailLightR);
            car.add(actualTailLightR.target);
        }

        function createRoad() {
            const textureLoader = new THREE.TextureLoader();
            const roadTexture = textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', (texture) => {
                texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 10);
            });
            roadTexture.colorSpace = THREE.SRGBColorSpace;
            const roadMaterial = new THREE.MeshStandardMaterial({
                map: roadTexture, color: 0x222222, roughness: 0.8, metalness: 0.1
            });
            const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
            road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2; road.position.y = 0;
            road.receiveShadow = true;
            scene.add(road);

            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            const lineSegmentLength = 4; const lineGapLength = 4;
            const numLineSegments = Math.floor(roadLength / (lineSegmentLength + lineGapLength));
            for (let i = 0; i < numLineSegments * 2; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.2, lineSegmentLength);
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2; line.position.y = 0.01;
                scene.add(line); roadLines.push(line);
            }
        }

        function createBuilding() {
            const buildingHeight = Math.random() * 30 + 10;
            const buildingWidth = Math.random() * 8 + 4;
            const buildingDepth = Math.random() * 8 + 4;
            const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
            const grayScale = Math.random() * 0.2 + 0.1;
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(grayScale, grayScale, grayScale + 0.05),
                roughness: 0.7, metalness: 0.2
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.castShadow = true;
            building.receiveShadow = true;

            if (Math.random() < 0.98) { 
                const numLights = Math.floor(Math.random() * 20) + 10; 
                for (let i = 0; i < numLights; i++) {
                    let lightColor;
                    let lightIntensity;
                    let lightWidth;
                    let lightHeight;

                    if (Math.random() < 0.90) { 
                        lightColor = 0xffe500; 
                        lightIntensity = 7.0 + Math.random() * 5.0; 
                        lightWidth = Math.random() * (buildingWidth * 0.10) + 0.15; 
                        lightHeight = Math.random() * (buildingHeight * 0.07) + 0.15; 
                    } else { 
                        const otherNeonColors = [0xff00ff, 0x00ffff, 0xff4500, 0x33cc33, 0x6666ff, 0xff8c00, 0xcc00cc]; 
                        lightColor = otherNeonColors[Math.floor(Math.random() * otherNeonColors.length)];
                        lightIntensity = 3.0 + Math.random() * 1.5; 
                        lightWidth = Math.random() * (buildingWidth * 0.30) + 0.3;
                        lightHeight = Math.random() * (buildingHeight * 0.18) + 0.25;
                    }

                    const lightMaterial = new THREE.MeshStandardMaterial({
                        emissive: lightColor,
                        emissiveIntensity: lightIntensity,
                        color: lightColor 
                    });

                    const lightGeometry = new THREE.PlaneGeometry(lightWidth, lightHeight);
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    
                    const faceMarginX = buildingWidth * 0.05; 
                    const faceMarginZ = buildingDepth * 0.05;
                    const faceMarginY = buildingHeight * 0.05;

                    const randomY = (Math.random() * (buildingHeight - 2 * faceMarginY - lightHeight)) - ((buildingHeight - lightHeight)/ 2 - faceMarginY);
                    const randomXOnFace = (Math.random() * (buildingWidth - 2 * faceMarginX - lightWidth)) - ((buildingWidth - lightWidth)/ 2 - faceMarginX);
                    const randomZOnFace = (Math.random() * (buildingDepth - 2 * faceMarginZ - (light.rotation.y === 0 || light.rotation.y === Math.PI ? lightWidth : lightHeight) )) - ((buildingDepth - (light.rotation.y === 0 || light.rotation.y === Math.PI ? lightWidth : lightHeight))/ 2 - faceMarginZ);

                    const side = Math.floor(Math.random() * 4);
                    const surfaceOffset = 0.051; 

                    if (side === 0) { 
                        light.position.set(buildingWidth / 2 + surfaceOffset, randomY, randomZOnFace);
                        light.rotation.y = Math.PI / 2;
                    } else if (side === 1) { 
                        light.position.set(-buildingWidth / 2 - surfaceOffset, randomY, randomZOnFace);
                        light.rotation.y = -Math.PI / 2;
                    } else if (side === 2) { 
                        light.position.set(randomXOnFace, randomY, buildingDepth / 2 + surfaceOffset);
                    } else { 
                        light.position.set(randomXOnFace, randomY, -buildingDepth / 2 - surfaceOffset);
                        light.rotation.y = Math.PI;
                    }
                    building.add(light);
                }
            }
            building.position.y = buildingHeight / 2;
            return building;
        }

        function createInitialBuildings() {
            const initialBuildingCount = 30;
            for (let i = 0; i < initialBuildingCount; i++) {
                const buildingL = createBuilding();
                buildingL.position.x = -(roadWidth / 2 + buildingL.geometry.parameters.width / 2 + Math.random() * 10);
                buildingL.position.z = buildingSpawnZ + (i / initialBuildingCount) * (buildingDespawnZ - buildingSpawnZ) * 3;
                scene.add(buildingL); buildings.push(buildingL);
                const buildingR = createBuilding();
                buildingR.position.x = (roadWidth / 2 + buildingR.geometry.parameters.width / 2 + Math.random() * 10);
                buildingR.position.z = buildingSpawnZ + (i / initialBuildingCount) * (buildingDespawnZ - buildingSpawnZ) * 3;
                scene.add(buildingR); buildings.push(buildingR);
            }
        }

        function createDistantBuilding() {
            const buildingHeight = Math.random() * 80 + 40; 
            const buildingWidth = Math.random() * 20 + 10; 
            const buildingDepth = Math.random() * 20 + 10;
            const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
            const distantBuildingMaterial = new THREE.MeshStandardMaterial({
                color: 0x101018, 
                roughness: 0.9,
                metalness: 0.1
            });
            const building = new THREE.Mesh(buildingGeometry, distantBuildingMaterial);

            if (Math.random() < 0.1) { 
                const numDimLights = Math.floor(Math.random() * 3) + 1;
                for (let i = 0; i < numDimLights; i++) {
                    const dimLightMaterial = new THREE.MeshBasicMaterial({ color: 0x333322 }); 
                    const dimLightGeom = new THREE.PlaneGeometry(Math.random() * 2 + 0.5, Math.random() * 2 + 0.5);
                    const dimLight = new THREE.Mesh(dimLightGeom, dimLightMaterial);
                    dimLight.position.set(
                        (Math.random() - 0.5) * buildingWidth * 0.8,
                        (Math.random() - 0.5) * buildingHeight * 0.8,
                        (Math.random() > 0.5 ? buildingDepth / 2 : -buildingDepth/2) + (Math.random() > 0.5 ? 0.05 : -0.05)
                    );
                     if(dimLight.position.z > buildingDepth/2) dimLight.rotation.y = 0; else dimLight.rotation.y = Math.PI;

                    building.add(dimLight);
                }
            }
            building.position.y = buildingHeight / 2; 
            return building;
        }

        function createInitialDistantSkyline() {
            const numDistantBuildings = 20; 
            for (let i = 0; i < numDistantBuildings; i++) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const distantBuilding = createDistantBuilding();
                distantBuilding.position.x = side * (roadWidth + Math.random() * 100 + distantBuilding.geometry.parameters.width/2); 
                distantBuilding.position.z = distantBuildingSpawnZ - Math.random() * 200; 
                scene.add(distantBuilding);
                distantSkyline.push(distantBuilding);
            }
        }

        function updateDistantSkyline() {
            distantSkyline.forEach(building => {
                building.position.z += gameSpeed * distantSkylineMoveSpeedFactor;
                if (building.position.z > distantBuildingDespawnZ) {
                    building.position.z = distantBuildingSpawnZ - Math.random() * 50;
                    const side = Math.random() > 0.5 ? 1 : -1;
                    building.position.x = side * (roadWidth + Math.random() * 100 + building.geometry.parameters.width/2);
                }
            });
        }
        
        function createBridge() {
            bridgeGroup = new THREE.Group(); 
            const bridgeBaseZ = -300; 
            bridgeGroup.position.z = bridgeBaseZ;
            bridgeGroup.position.y = 40; 
            bridgeGroup.rotation.y = Math.PI / 2; 
            scene.add(bridgeGroup);

            const bridgeRedMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcc0000, 
                roughness: 0.6, 
                metalness: 0.3,
                emissive: 0x330000, 
                emissiveIntensity: 0.5
            });
            const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.5, metalness: 0.7 });

            const roadwayWidth = 12;
            const roadwayHeight = 0.5;
            const roadwayLength = 60; 
            const roadwayGeometry = new THREE.BoxGeometry(roadwayWidth, roadwayHeight, roadwayLength);
            const roadway = new THREE.Mesh(roadwayGeometry, bridgeRedMaterial);
            roadway.position.y = 0; 
            bridgeGroup.add(roadway);

            const towerWidth = 2;
            const towerHeight = 40; 
            const towerDepth = 2;
            const towerGeometry = new THREE.BoxGeometry(towerWidth, towerHeight, towerDepth);

            const towerL = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerL.position.set(-(roadwayWidth / 2 + towerWidth / 2), towerHeight / 2 - roadwayHeight / 2, -roadwayLength / 2 + 5);
            bridgeGroup.add(towerL);

            const towerR = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerR.position.set(roadwayWidth / 2 + towerWidth / 2, towerHeight / 2 - roadwayHeight / 2, -roadwayLength / 2 + 5);
            bridgeGroup.add(towerR);
            
            const towerL2 = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerL2.position.set(-(roadwayWidth / 2 + towerWidth / 2), towerHeight / 2 - roadwayHeight / 2, roadwayLength / 2 - 5);
            bridgeGroup.add(towerL2);

            const towerR2 = new THREE.Mesh(towerGeometry, bridgeRedMaterial);
            towerR2.position.set(roadwayWidth / 2 + towerWidth / 2, towerHeight / 2 - roadwayHeight / 2, roadwayLength / 2 - 5);
            bridgeGroup.add(towerR2);

            const towerLightColor = 0xffffff; 
            const towerLightIntensity = 25; 
            const towerLightDistance = towerHeight * 1.8; 
            const towerLightAngle = Math.PI / 7; 
            const towerLightPenumbra = 0.3;

            [towerL, towerR, towerL2, towerR2].forEach(tower => {
                const upLight = new THREE.SpotLight(towerLightColor, towerLightIntensity, towerLightDistance, towerLightAngle, towerLightPenumbra, 1);
                upLight.position.set(tower.position.x, roadway.position.y + roadwayHeight + 1, tower.position.z); 
                upLight.castShadow = false; 
                const targetObject = new THREE.Object3D();
                targetObject.position.set(tower.position.x, roadway.position.y + towerHeight * 3, tower.position.z); 
                bridgeGroup.add(targetObject); 
                upLight.target = targetObject;
                bridgeGroup.add(upLight);
            });

            const underRoadLightColor = 0xaaaaff; 
            const underRoadLightIntensity = 20; 
            const underRoadLightDistance = 30;  
            const underRoadLightAngle = Math.PI / 3; 

            for(let i = -2; i <= 2; i += 2) { 
                if (i === 0 && roadwayLength < 30) continue; 
                const downLight = new THREE.SpotLight(underRoadLightColor, underRoadLightIntensity, underRoadLightDistance, underRoadLightAngle, 0.3, 1.5);
                downLight.position.set(i * (roadwayWidth / 6), roadway.position.y - roadwayHeight - 0.5, 0); 
                downLight.castShadow = false; 
                const downTarget = new THREE.Object3D();
                downTarget.position.set(i * (roadwayWidth / 6), roadway.position.y - roadwayHeight - 15, 0);
                bridgeGroup.add(downTarget);
                downLight.target = downTarget;
                bridgeGroup.add(downLight);
            }

            const roadwayPointLightColor = 0xffccaa; 
            const roadwayPointLightIntensity = 0.8;
            const roadwayPointLightDistance = 20;
            const numRoadwayLights = 4;
            for (let i = 0; i <= numRoadwayLights; i++) {
                const t = i / numRoadwayLights;
                const pointLight = new THREE.PointLight(roadwayPointLightColor, roadwayPointLightIntensity, roadwayPointLightDistance, 1.5);
                pointLight.position.set(0, roadway.position.y + 2, -roadwayLength/2 + t * roadwayLength);
                bridgeGroup.add(pointLight);
            }


            const mainCableRadius = 0.2;
            const mainCableSegments = 5; 
            const cableSpan = roadwayLength - 10; 
            const cableSag = 10; 

            for (let side = -1; side <= 1; side += 2) { 
                const cableStartX = side * (roadwayWidth / 2 + towerWidth / 2 - mainCableRadius * 2);
                const cableTopY = towerHeight - roadwayHeight/2 - mainCableRadius;
                let prevPoint = new THREE.Vector3(cableStartX, cableTopY, -cableSpan / 2);

                for (let j = 1; j <= mainCableSegments; j++) {
                    const t = j / mainCableSegments;
                    const currentX = cableStartX;
                    const currentY = cableTopY - cableSag * (1 - Math.pow(2 * t - 1, 2)); 
                    const currentZ = -cableSpan / 2 + t * cableSpan;
                    const nextPoint = new THREE.Vector3(currentX, currentY, currentZ);
                    const segmentLength = prevPoint.distanceTo(nextPoint);
                    const cableSegmentGeom = new THREE.BoxGeometry(mainCableRadius*2, mainCableRadius*2, segmentLength);
                    const cableSegment = new THREE.Mesh(cableSegmentGeom, cableMaterial);
                    cableSegment.position.copy(prevPoint).lerp(nextPoint, 0.5); 
                    cableSegment.lookAt(nextPoint); 
                    bridgeGroup.add(cableSegment);
                    prevPoint = nextPoint;
                }
            }

            const suspenderRadius = 0.05;
            const numSuspenders = 10; 
            for (let side = -1; side <= 1; side += 2) {
                 const mainCableX = side * (roadwayWidth / 2 + towerWidth / 2 - mainCableRadius*2);
                for (let j = 0; j <= numSuspenders; j++) {
                    const t = j / numSuspenders;
                    const suspenderZ = -cableSpan / 2 + t * cableSpan;
                    const mainCableY = (towerHeight - roadwayHeight/2 - mainCableRadius) - cableSag * (1 - Math.pow(2 * ( (suspenderZ + cableSpan/2) / cableSpan ) - 1, 2));
                    const suspenderHeight = mainCableY - (roadwayHeight / 2); 
                    if (suspenderHeight <= 0) continue; 
                    const suspenderGeom = new THREE.CylinderGeometry(suspenderRadius, suspenderRadius, suspenderHeight, 6);
                    const suspender = new THREE.Mesh(suspenderGeom, cableMaterial);
                    suspender.position.set(mainCableX, roadwayHeight / 2 + suspenderHeight / 2, suspenderZ);
                    bridgeGroup.add(suspender);
                }
            }
        }

        // --- STREET LIGHT POST FUNCTIONS ---
        function createLightPost() { 
            const postGroup = new THREE.Group();
            postGroup.name = "lightPost"; 

            const poleHeight = 5.5 + Math.random() * 1.0; // Taller posts
            const poleRadius = 0.1;
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.4 });
            const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius * 0.9, poleHeight, 8);
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = poleHeight / 2;
            pole.castShadow = true;
            postGroup.add(pole);

            const fixtureSize = 0.3;
            const fixtureGeometry = new THREE.BoxGeometry(fixtureSize, fixtureSize * 0.8, fixtureSize * 1.5); 
            const fixtureMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.y = poleHeight - fixtureSize * 0.4; 
            
            // Determine arm direction based on which side of the road the post will be on
            // This will be set when the post is cloned and positioned.
            // For the prototype, let's assume it extends towards positive X from pole center.
            fixture.position.x = 0.3; 
            postGroup.add(fixture);


            const lightColor = 0xffddaa; // Warm yellow
            const intensity = 20; // Brighter street lights
            const distance = 18;  // Increased reach
            const angle = Math.PI / 3.5; // Slightly wider cone
            const penumbra = 0.3;
            const decay = 1.5;

            const spotLight = new THREE.SpotLight(lightColor, intensity, distance, angle, penumbra, decay);
            spotLight.position.set(fixture.position.x, fixture.position.y - fixtureSize * 0.5 + 0.1, fixture.position.z);
            
            const targetObject = new THREE.Object3D();
            targetObject.position.set(spotLight.position.x, -poleHeight + 0.1, spotLight.position.z); 
            
            spotLight.target = targetObject;
            postGroup.add(spotLight);
            postGroup.add(targetObject); 

            spotLight.castShadow = true; 
            spotLight.shadow.mapSize.width = 256; 
            spotLight.shadow.mapSize.height = 256;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = distance;
            spotLight.shadow.bias = -0.001; // Helps with shadow acne on the road

            return postGroup;
        }

        function createInitialLightPosts() {
            const numPostsPerSide = Math.floor((lightPostDespawnZ - lightPostSpawnZ) / lightPostSpacing);
            const postPrototype = createLightPost(); // Create one prototype

            for (let i = 0; i < numPostsPerSide; i++) {
                // Left side
                const postL = postPrototype.clone(true); // Clone the prototype
                postL.position.x = -(roadWidth / 2 + 0.8); 
                // Adjust fixture arm for left side (points towards road, so negative X relative to pole)
                const fixtureL = postL.children.find(child => child.geometry instanceof THREE.BoxGeometry && child.material.color.getHexString() === '333333');
                const spotLightL = postL.children.find(child => child instanceof THREE.SpotLight);
                if(fixtureL) fixtureL.position.x = -0.3;
                if(spotLightL) {
                    spotLightL.position.x = -0.3;
                    spotLightL.target.position.x = -0.3;
                }
                postL.position.z = lightPostSpawnZ + i * lightPostSpacing + Math.random() * lightPostSpacing * 0.3;
                scene.add(postL);
                lightPosts.push(postL);

                // Right side
                const postR = postPrototype.clone(true); // Clone again for the right side
                postR.position.x = (roadWidth / 2 + 0.8);
                 // Fixture arm for right side is already correct (points towards road, positive X relative to pole)
                postR.position.z = lightPostSpawnZ + i * lightPostSpacing + Math.random() * lightPostSpacing * 0.3;
                scene.add(postR);
                lightPosts.push(postR);
            }
        }

        function updateLightPosts() {
            lightPosts.forEach(post => {
                post.position.z += gameSpeed * lightPostMoveSpeedFactor;

                if (post.position.z > lightPostDespawnZ) {
                    post.position.z -= (lightPostDespawnZ - lightPostSpawnZ) + lightPostSpacing * (0.5 + Math.random() * 0.5) ; // Add more randomness to Z reset
                }
            });
        }
        // --- END STREET LIGHT POST FUNCTIONS ---


        function updateRoad() {
            if (road.material.map) {
                road.material.map.offset.y -= gameSpeed * 0.02;
            }
            roadLines.forEach((line, index) => {
                const isLeftLane = index < roadLines.length / 2;
                const lineBaseX = isLeftLane ? -roadWidth / 4 : roadWidth / 4;
                line.position.x = lineBaseX;
                let currentZ = line.userData.initialZ !== undefined ? line.userData.initialZ : (index % (roadLines.length / 2)) * 8 - roadLength / 2;
                currentZ += gameSpeed;
                if (currentZ > roadLength / 2) { currentZ -= roadLength; }
                line.userData.initialZ = currentZ; line.position.z = currentZ;
            });
        }

        function updateBuildingsAndBridge() {
            buildings.forEach(building => {
                building.position.z += gameSpeed * buildingMoveSpeedFactor;
                if (building.position.z > buildingDespawnZ) {
                    building.position.z = buildingSpawnZ - Math.random() * 30;
                    const side = building.position.x < 0 ? -1 : 1;
                    building.position.x = side * (roadWidth / 2 + building.geometry.parameters.width / 2 + Math.random() * 10);
                }
            });
            if (bridgeGroup) { 
                bridgeGroup.position.z += gameSpeed * bridgeMoveSpeedFactor;
                if (bridgeGroup.position.z > distantBuildingDespawnZ + 150) { 
                    bridgeGroup.position.z = distantBuildingSpawnZ - 200; 
                }
            }
        }

        function handleCarMovement() {
            const roadBoundary = roadWidth / 2 - carModelWidth / 2 - 0.1;
            if (keys.ArrowLeft) {
                car.position.x = Math.max(car.position.x - carSpeed, -roadBoundary);
            }
            if (keys.ArrowRight) {
                car.position.x = Math.min(car.position.x + carSpeed, roadBoundary);
            }
            targetCameraX = car.position.x * cameraSideViewFactor;
            targetCameraLookX = car.position.x * 0.8;
            camera.position.x += (targetCameraX - camera.position.x) * cameraLagFactor;
            
            const cameraLightTarget = camera.getObjectByName("cameraLightTarget");
            if (car && cameraLightTarget) { 
                const targetPosition = new THREE.Vector3();
                car.getWorldPosition(targetPosition); 
                camera.worldToLocal(targetPosition);  
                cameraLightTarget.position.copy(targetPosition);
            }


            const lookAtPosition = new THREE.Vector3(
                targetCameraLookX, camera.position.y - 1.0, car.position.z - 10
            );
            camera.lookAt(lookAtPosition);
        }

        function animate() {
            requestAnimationFrame(animate);
            handleCarMovement();
            updateRoad();
            updateBuildingsAndBridge();
            updateDistantSkyline(); 
            updateLightPosts(); // Update light posts
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        init();
    </script>
</body>
</html>
